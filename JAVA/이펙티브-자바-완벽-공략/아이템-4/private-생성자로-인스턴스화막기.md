# 4. 인스턴스화를 막으려거든 private 생성자를 사용하라

- 정적 메서드만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 클래스가 아니다. 
  - 유틸리티성 클래스라 하면 static 한 메서드만을 가지고 있는 클래스
  - String 유틸리티, Date 유틸리티: 무언가를 도와주는 , 클래스를 통해서 함수 접근 가능(인스턴스화가 필요 없다.)
- 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.
  - abstract 클래스 자체로는 인스턴스화가 되지 않지만 해당 abstract 클래스를 상속받은 클래스로는 인스턴스화가 가능하다.(하위클래스는 상위 클래스의 생성자 사용 가능)
  - 게다가 abstract 키워드로 인해서 상속받아서 써야 하는 클래스인가? 하고 헷갈리게 한다. 
```
/**
 * 이 클래스는 인스턴스를 만들 수 없습니다. (2)
 */
private UtilityClass() { //(1)
    throw new AssertionError(); //오면 안되는 상황에 접근한것이기 때문에 오류를 내뿜게 한다. 
}
```
- (1) private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다. 
- (2) 생성자에 주석으로 인스턴스화 불가한 이유를 설명하는 것이 좋다.
- 상속을 방지할 때도 같은 방법을 사용할 수 있다.
