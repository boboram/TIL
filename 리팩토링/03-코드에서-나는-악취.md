# 03. 코드에서 나는 악취 

- 113 ~ 131 page

# 악취
- **기이한 이름**
  - 추리소설이 아니다. 단순명료해야 좋은 코드다.
  - 함수 선언 바꾸기, 변수 이름 바꾸기, 필드 이름 바꾸기 
- **중복 코드**
  - 똑같은 코드 구조가 두 군데 이상 있을 때는 그 부분을 하나로 통일하자
  - 구린 경우 예시
    - 한 클래스의 두 메서드 안에 같은 코드가 들어 있는 경우, 메서드 추출 기법을 적용하자.
    - 두 하위 클래스에 같은 코드가 들어 있는 경우, 메서드 추출 기법 -> 메서드 상향 기법 
    - 기능이 같은데 알고리즘이 다르다면 단순한 알고리즘 택 
    - 상관없는 두 클래스에 동일 로직 -> 다른 클래스에서 호출하도록 처리 
- **장황한 메서드**
  - 최적의 상태로 장수하는 객체 프로그램을 보면 공통적으로 메서드 길이가 짧다.
  - 메서드의 기능을 한눈에 알 수 있는 메서드명을 사용하면 코드를 분석할 필요가 없다. 
  - 주석을 달아야 할 것 같은 부분에 주석 대신 메서드를 작성한다. 
  - 한 줄밖에 안 되는 코드라도 별도의 주석이 달려 있을 정도로 다른 기능을 수행한다면 메서드로 추출할 것 
  - 조건문,루프도 역시 메서드로 뺄 것 
- **방대한 클래스**
  - 클래스에 인스턴스 변수가 너무 많으면 중복코드가 반드시 존재하게 마련이다.
  - 서로 연관된 변수를 골라서 클래스로 빼내기 
- **과다한 매개변수**
  - 객체의 등장으로 바뀐 상황 : 메서드가 필요로 하는 각종 데이터는 그 메서드가 속한 클래스에 들어 있음 
  - 매개변수 세트가 길수록 수정을 하거나 이해를 하기가 힘들다.
- **수정의 산발 == 뒤엉킨 변경**
  - 발생 원인
    - 한 클래스가 다양한 이유로 자주 수정될 때 발생 : 목적이 다르다면 여러개의 변경 객체로 분리할 것 
- **기능의 산재 == 산탄총 수술**
  - 여러 클래스의 자잘한 부분을 고쳐야 한다면 꼭 수정해야 하는 부분을 놓치기 쉽다.
  - 수정할 부분들을 전부 하나의 클래스 안에 넣어야 한다. 
    - 기존 클래스에 넣는게 부적절해 보인다면 새로운 클래스를 만든다.
  > 하나의 클래스에서 여러 기능을 수정하던(수정의 산발) 여러 클래스에서 자잘하게 수정해야 하던(기능의 산재) 수정과 클래스가 일대일 대응되게 깔끔하게 정리해야 한다.
- **잘못된 소속 == 기능 편애**
  - 소속이 잘못된 메서드 : 더 자주 접근하는 클래스로 이동
- **데이터 뭉치**
  - 값 하나를 삭제했을 때 나머지 데이터만으로는 의미가 없다면 객체로 환생시키자.
- **기본형 집착**
  - `if (a < upper && a > lower)` : 간단한 계산입에서 수식이 두개 들어가야 한다.
  - **기본형 객체로 바꾸기** : 의미있는 자료형들로 만들 수 있다.
  - 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면 **타입 코드를 서브클래스로 바꾸기** & **조건부 로직을 다형성으로 바꾸기**
  - 자주 몰려다니는 데이터 뭉치도 클래스 추출하기와 매개변수 객체 만들기를 이용하자. 
- **반복되는 switch 문**
  - 중복된 switch 문이 문제가 되는 있우는 조건절을 하나 추가할 때마다 다른 switch 문들도 추가해줘야 하기 때문 
  - 최근에는 다형성이 자리 잡아서 단순히 switch 문을 썼다고 자동으로 검토 대상이 되는지 않는다.
- **반복문**
  - 필터나 맵 같은 파이프라인 연산을 사용하여 각 원소들이 어떻게 처리되는지 쉽게 파악하자.
- **성의 없는 요소**
  - 클래스 내부에 함수가 한개라던지와 같은 행색을 보이는 프로그램 요소는 함수 인라인하기 or 클래스 인라인하기로 처리한다. 상속 후엔 계층 합치기를 적용하자.
- **추측성 일반화**
  - **나중에 필요할 거야** 라는 생각으로 당장은 필요 없는 모든 종류의 코드는 제거하자. 
- **임시 필드**
  - 특정 상황에서만 값이 사용되는 필드라면 코드를 이해하기 어렵다.
  - 클래스 추출하기 혹은 함수 옮기기를 통해서 임시 필드들과 관련된 코드를 모조리 새 클래스에 옮긴다.
- **메시지 체인**
  - 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다. 그래서 네비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다. -> 위임 숨기기로 해결한다. 
  - 함수 호출하기로 결과 객체를 사용하는 코드 일부를 따로 빼내어 함수 옮기기로 체인을 숨긴다.
- **중개자**
  - 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임한다면? 중개자 제거하기를 활용하여 실제로 일을 처리하는 객체와 직접 소통하게끔 하자. 
    - 위임 메서드를 제거한 후 남는 일이 없다면 호출하는 쪽으로 함수 인라인 처리하자. 
- **내부자 거래**
  - 모듈 사이의 데이터 거래가 많으면 결합도 높아진다. 적절하게 떼어내자. (함수 옮기기, 필드 옮기기, 위임 숨기기) 
- **거대한 클래스**
  - 한 클래스가 너무 많은 일을 하려다 보면 필드수가 상당해진다. 
  - 클래스 추출하기로 필드들 일부를 묶는다.
  - 슈퍼클래스 추출 또는 타입 코드를 서브클래스로 바꾸기를 적용하는 방법도 있다.  
  - 자체적으로 중복을 제거해야한다.
- **서로 다른 인터페이스의 대안 클래스들** 
  - 필요에 따라 클래스를 교체하기 위해선 인터페이스가 같아야 한다. 
- **데이터 클래스**
  - 데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다. 
  - 외부에서 해당 데이터 클래스를 조작하는 메서드가 있다면 함수를 가져올 수 있는지 확인하여 함수 옮기기 처리하자. 
  - 불변 데이터라면 굳이 캡슐화 할 필요 없이 필드 자체를 공개해도 된다.
- **상속 포기**
- **주석**
  - 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.  
