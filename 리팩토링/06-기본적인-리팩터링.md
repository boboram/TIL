# 06. 기본적인 리팩터링

## 함수 추출하기 158~168page
- 코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 이름을 붙인다. 
  - 길이를 기준으로 삼을 수 있다. 
  - 목적과 구현을 분리 : 코드를 분석하는데 오랜 시간이 걸린다면 그 부분을 함수로 추출한 뒤 '무슨 일' 에 걸맞는 이름을 짓는다. 
  - 함수를 짧게 만들면 캐싱하기가 더 쉽기 때문에 컴파일러가 최적화하는 데 유리한 경우가 많다. 
  - 짧은 함수의 이점은 해당 내부 코드가 무슨 일을 하는지 명확한 이름을 지어야만 발휘된다. 
- 절차
  - 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다('어떻게'가 아닌 '무엇을' 하는지가 드러나야 한다)
    - 명확한 이름이 떠오르지 않다면 함수로 추출하면 안된다. 
  - 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣는다.
    - 지역&매개 변수가 있다면 인수로 전달한다. 
    - 수정되는 지역변수가 너무 많다면? 함수 추출을 멈추고, 변수 쪼개기나 임시 변수를 질의 함수로 바꾸기와 같은 다른 리팩터링을 적용해서 변수를 사용하는 코드를 단순하게 바꿔본다. 그 후 함수 추출을 다시 시도한다.
  - 변수를 다 처리했다면 컴파일한다.
  - 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다. (추출 함수로 위임한다.)
  - 테스트한다.
  - 추출된 함수와 비슷한 코드가 있는지 확인후 바꿀지 검토한다. 

## 함수 인라인하기 169~172page
```
function getRating(driver) {
  return moreThanFiveLateDeliveries(driver) ? 2 : 1;
}

function moreThanFiveLateDeliveries(driver) {
  return driver.numberOfLateDeliveries > 5;
}
```
보다는!
```
function getRating(driver) {
  return (driver.numberOfLateDeliveries > 5) ? 2 : 1;
}
```
- 인라인 대상 : 리팩터링 과정에서 잘못 추출된 함수들, 간접 호출을 너무 과하게 쓰는 코드
- 절차
  - 다형 메서드는 인라인하면 안됨
  - 인라인할 함수를 호출하는 곳을 모두 찾기
  - 각 호출문을 함수 본문으로 교체
  - 하나씩 교체할 때마다 테스트 
  - 함수 정의(원래 함수)를 삭제 
- 상황이 복잡하다면 함수 인라인을 적용해서는 안된다. 

## 변수 추출하기 173 ~ 177page
```
return order.quantity * order.itemPrice -
  Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 +
  Math.min(order.quantity * order.itemPrice * 0.1, 100);
```
보다는
```
const basePrice = order.quantity * order.itemPrice;
const quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05;
const shipping = Math.min(basePrice * 0.1, 100);

return basePrice - quantityDiscount + shipping;
```
이 좋다.

(예제만 봐도 좋아보인다. 직관적이고 좋군..)

- 표현식이 너무 복잡해서 이해하기 어렵다면 각단계별로 명확한 이름의 변수명을 가진 변수로 따로 추출하면 좋다.
- 함수 외적으로도 사용되는 의미라면 변수가 아닌 함수로 추출한다.
- 절차
  - 추출하려는 표현식에 부작용은 없는지 확인
  - 불변 변수를 하나 선언하고 이름을 붙일 표현식의 복제본을 대입한다.
  - 원본 표현식을 새로 만든 변수로 교체한다.
  - 테스트한다.
  - 표현식을 여러 곳에서 사용한다면 각각을 새로 만든 변수로 교체한다. 하나 교체할 때마다 테스트한다.
- 클래스라면 해당 값들을 하나의 함수로 나타낸다.
  - 객체의 장점 : 객체는 특정 로직과 데이터를 외부와 공유하려 할 때 공유할 정보를 설명해주는 적당한 크기의 문맥이 되어준다. 


## 변수 인라인하기 178page
```
let basePrice = anOrder.basePrice;
return (basePrice > 1000);
```
보다는
```
return anOrder.basePrice > 1000;
```
가 낫다.
- 그 이름이 원래 표현식과 다를 바 없다면 변수를 인라인하는 것이 좋다. 

## 함수 선언 바꾸기 179 ~ 187 page
- 소프트웨어는 소프트하기 때문에 연결부를 수정할 수 있다. 연결부는 함수고 함수명을 해당 함수가 무슨 일을 하는지 한번에 알 수 있는 명칭으로 변경해야 한다.
> 좋은 이름을 떠올리는 데 효과적인 방법이 하나 있다. 바로 주석을 이용해 함수의 목적을 설명해보는 것이다. 그러다 보면 주석이 멋진 이름으로 바뀌어 되돌아올 때가 있다. 
- 함수의 매개변수도 마찬가지다. 매개변수는 함수가 외부 세계와 어우러지는 방식을 정의한다.
- 인터페이스 내부에 종속시킬 것인지 외부에서도 사용할 수 있는 매개변수를 받을 것이지에 대한 문제에 대한 정답은 정답이 없다는 것이다.
  - 더 나은 방법이 떠오른 때마다 올바른 방법을 적용하면 되는데 함수 선언 바꾸기 리팩터링에 친숙해져야 한다. 
- 절차는 두가지를 설명한다.
  - **간단한 절차** : 단순히 메서드를 원하는 상태로 변경 후 수정하여 테스트 하는 방법
  - **마이그레이션 절차** : 임시 이름을 가진 새로운 함수를 생성하여 작업후 기존 함수를 임시함수로 변경후 테스트 -> 실제로 기존 함수를 호출했던 코드 선언을 수정 후 테스트 
    - 매개변수를 추가하거나 매개변수를 속성으로 바꾸기 같은 간단한 경우가 아니라면 사용 

## 변수 캡슐화하기 188 ~ 193 page 
- 데이터는 함수보다 다루기 더 까다롭다. 참조하는 모든 부분을 한 번에 바꿔야 코드가 제대로 작동한다.
- 접근할 수 있는 범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화하는 것이 가장 좋을 때가 많다.
- 글쓴이는 유효범위가 함수 하나보다 넓은 가변 데이터는 모두 이런 식으로 캡슐화한다.
  - 자주 사용하는 데이터에 대한 결합도가 높아지는 일을 막을 수 있다. 
  - private으로 변수를 선언하라고 하는 이유
- 불변 데이터는 가변 데이터보다 캡슐화할 이유가 적다. 
- **절차**
  - 변수로의 접근과 갱신을 전담하는 캡슐화 함수 생성
  - 정적 검사 수행
  - 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 수정, 하나씩 바꿀 때마다 테스트
  - 변수의 접근 법위 제한 
  - 테스트
  - 변수 값이 레코드라면 레코드 캡슐화 적용할지 고려 
- 기본 캡슐화 기법(getter,setter) 은 데이터 항목을 **참조하는 부분만** 캡슐화한다.
  - 필드값 변경 제어는 불가능 
- 내용을 변경하는 행위도 캡슐하하고 싶다면? 그 값을 수정할 수 없게 바꾸기(게터에 복사본 반환) / 레코드 캡슐화하기 
- 데이터의 사용 범위가 넓을수록 적절히 캡슐화하는게 좋다.

## 변수 이름 바꾸기 194~196 page
- `let a = height * widht;` -> `let area = height * widht;`
- 함수 호출 한 번으로 끝나지 않고 값이 영속되는 필드라면 이름에 더 신경 써야 한다. 
- 절차
  - 폭넓게 쓰이는 변수라면 변수 캡슐화하기를 고려한다. 
  - 이름을 바꿀 변수를 참조하는 곳을 모두 찾아서, 하나씩 변경한다. 
  - 테스트한다. 
- 해당 변수를 사용하는 곳이 많다면 복제본을 만들고 테스트 후 문제 없으면 제거하는 식으로 처리한다.
- 기존 변수명이 `cpNm`이라고 한다면 아래와 같은 식으로 복제본을 만드는 것이다! 
```
const companyName = "애크미 구스베리";
const cpyNm = companyName;
```

## 매개변수 객체 만들기 197 ~ 201 page
```
function amountInvoiced(startDate, endDate) {...}
```
보다는
```
function amountInvoiced(aDateRange) {...}
```
로!!
- 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해지고 매개변수 수가 줄어든다.
- 데이터 구조에 담길 데이터에 공통으로 적용되는 동작을 추출해서 함수로 만들어 데이터 구조를 활용하도록 하는 것이 좋다.
- 클래스로 만들어두면 관련 동작들을 이 클래스로 옮길 수 있다는 이점이 생긴다. 

## 여러 함수를 클래스로 묶기 202 ~ 207 page
```
function base(aReading) {...}
function taxableCharge(aReading) {...}
function calculateBaseCharge(aReading) {...}
```
보다는
```
class Reading {
  base() {...}
  taxableCharge() {...}
  calculateBaseCharge() {...}
}
```
가 낫다!!

- 클래스로 묶으면 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있고, 각 함수에 전달되는 인수를 줄여서 객체 안에서의 함수 호출을 간결하게 만들 수 있다.
- 절차
  - 함수들이 공유하는 공통 데이터 레코드를 캡슐화 
  - 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다. -> 공통 레코드의 멤버는 함수 호출문의 인수 목록에서 제거한다.
  - 데이터를 조작하는 로직들은 함수로 추출해서 새 클래스로 옮긴다. 
- 프로그램의 다른 부분에서 데이터를 갱신할 가능성이 꽤 있을 때는 클래스로 묶어두면 큰 도움이 된다. -> 파생 데이터 모두를 필요한 시점에 계산되게 만들어 저장된 데이터를 갱신하더라도 문제가 생길 일이 없다.
