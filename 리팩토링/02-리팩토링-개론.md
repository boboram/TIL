# Ch-02. 리팩토링 개론

- 75 ~ 98Page
## 리팩토링이란 무엇인가
- 명사 : 겉으로 드러나는 기능은 그대로 둔 채, **알아보기 쉽고 수정하기 간편하게** 소프트웨어 내부를 수정하는 작업
- 동사 : 리팩토링 기법을 연달아 적용해서 **겉으로 드러나는 기능은 그대로 둔 채** 소프트웨어 구조를 변경한다.
- 리팩토링은 성능 최적화와 상반된다. 

### 모자 두 개
- 기능 추가와 리팩토링이라는 별개의 두 작업에 시간을 분배해야 함 
- 기능을 추가할 때 코드를 수정하지 말고 기능만 추가해야 한다. 
- 테스트를 통해 진행 상태를 파악하면 된다.
- 리팩토링시에는 코드 추가가 아닌 코드 구조 개선만 해야 한다. 

## 리팩토링은 왜 해야 하나

- **소프트웨어 설계가 개선되니까**  
  - 코드 설계가 깔끔하지 안으면 보통 기능이 같은 코드가 여기저기 중복되어 있어서 쓸데없이 코드만 길어진다.🥺 
- **소프트웨어를 이해하기가 더 쉬워진다.**
  - 본인이 작성한 소스 코드를 이용하는 대산은 컴퓨터만이 아니며 다른 팀원도 존재한다. 
  - 본인의 코드를 다른 개발자가 신속히 이해하지 못해 수정하는데 오래 걸린다면 큰 문제다. 
  - 리팩토링은 제대로 실행되지만 구조가 완전하지 못한 코드에 대해 실시하는 것 
  - **우선 창 밖이 보이게 뿌연 유리창부터 닦는 일** : 리팩토링을 실시하면 낯선 코드를 쉽게 이해 가능 
- **버그를 찾기가 쉬워지니까** : 리팩토링을 통해 빈틈없는 코드 작성 가능 
- **프로그래밍 속도가 빨라지니까** : 프로그램이 아닌 프로그래밍 속도이다. 개발 속도가 빨라진다. 

## 리팩토링은 어떨 때 필요한가
- 일부러 시간 내서 하진 말라 / 일상적으로 틈틈이 해야 한다. 
  - 다른 작업을 하는데 리팩토링을 실시하면 그 작업이 쉬워지기 때문에 하는 것이다.
- **같은 작업의 삼진 아웃 때** : 세번째로 중복작업시에 실시 
- **기능을 추가할 때** : 코드를 이해하기 쉽게 만들고 기능을 파악하고, 리팩토링하면 더 이해가 쉬워질것이란 판단이 들 때 리팩토링 한다. 
- **버그를 수정할 때** 
- **코드를 검수할 때** 
  - 사람마다 지식과 경험 분야가 다르고 검수중에 더 많은 이들의 기발한 아이디어를 제한받을 기회도 생긴다.
  - 코드 검수 결과도 더 구체적으로 나오고 떠오른 아이디어를 직접 구현해 볼 수도 있다.
  - 검수자 한명 + 최초 코드 작성자들로 구성하는 것이 좋다. 

## 리팩토링의 효용성(feat. 켄트 벡)
- 수정하기 힘든 상황
  - 코드를 알아보기 힘들 때
  - 중복된 로직이 들어 있을 때 
  - 추가 기능을 넣어야 해서 실행 중인 코드를 변경해야 할 때 
  - 조건문 구조가 복잡할 때 
😭😭😭😭😭
- 프로그램은 코드를 알아보기 쉽고, 모든 로직이 한곳에 있으며, 기존 기능을 건드릴 필요 없이 조건문 구조가 최대한 간결하게끔 작성해야 한다.
- 리팩토링은 신속한 개발 공정을 가능하게 하는 성질을 가중하면서 가치를 높이는 일이다.

## 인다이렉션과 리팩토링
- 컴퓨터 과학에선 모든 문제의 해결책이 인다이렉션 계층을 하나 더 만드는 것이라고 가르친다. 
- 인다이렉션은 양날의 검이다. 한 부분을 둘로 쪼개면 관리할 부분이 늘어난다. 
- 장점 
  - 로직 공유 : 하나의 로직을 여러 곳에서 공유 가능 
  - 의도와 구현부를 따로 나타냄 : 그 코드의 구조에 대한 대부분의 주요 정보를 잘 드러내는 코드 작성 가능 
  - 수정 부분을 분리 
  - 조건문을 코드화 : 조건문을 메시지로 바꾸면 중복 코드가 줄어들어 명료해지며 동시에 유연성도 높아진다. 

## 리팩토링 관련 문제들 

- 데이터베이스
  - DB 스키마 변경시 발생되는 데이터 이전 문제는 시간+위험성이 높다. 
  - 객체 모델과 데이터베이스 모델 사이에 별도의 소프트웨어 계층을 두는 방법 : 수정 필요 없이 중개 계층만 수정하면 된다. 복잡하지만 유연성 존재 
  - 객체 모델의 일정 부분들ㅇ
- 인터페이스 변경 
  - 메서드를 사용하는 모든 코드에 접근할 수 있다면 메서드명 변경쯤은 문제가 되지 않는다. 
    - but 인터페이스가 사용되는 부분을 찾는게 불가능하다면 문제 발생 
  - 기존 인터페이스, 새 인터페이스 모두 그대로 유지시켜야 한다. 
  - 꼭 필요한 경우가 아니라면 인터페이스를 published 타입이 되기 않게 하기 
- 설계를 수정하는 일 : 어렵긴 하나 가능하다. 수정후에 간간이 새 기능을 순조롭게 받아 낼 수 있다.
- 리팩토링하면 안 되는 상황 
  - 코드를 처음부터 새로 작성할 때 
    - 코드가 돌아가지 않는다면 새로 작성하라는 신호임 
  - 납기가 임박했을 때 

## 리팩토링과 설계 
- 사전 설계 : 코딩 후 리팩토링을 하면 사전 설계의 역할이 변한다. 
- 리팩토링을 하면 중점적인 작업이 달라진다.
  - 작업 중점 이동 : 적당한 솔루션만 생각해내고 리팩토링을 실시한다. 
  - 설계가 단순해진다. 
  - 유연한 SW는 구현은 쉽고 유지보수하긴 힘들다. : 시스템 전체를 유연하게 할 필요는 없으며 그러한 부분은 일부이다. 
  - 리팩토링을 통해 수정시 위험성에 대처할 수 있다. : 단순 솔루션을 구현하고서 나중에 유연 솔루션으로 리팩토링하려면 얼만큼 수고가 들지? 하고 고민하자.
    - 문제가 없다고 판단되면 단순 솔루션을 구현하자. 
 - 리팩토링이 익숙해지면 초기에 단순 솔루션을 개발하고서 이후에 유연 솔루션으로 수정하는 것이 두렵지 않다. 

## 빈 날짜 인스턴스를 생성하느라 낭비한 시간 
- 시스템 내부가 어떻게 돌아가는지 정확히 알고 있더라도 추측하지 말고 **성능 측정**을 실시하자. 

## 리팩토링과 성능 
- 소프트웨어 튜닝을 가능하게 만들고서 충분한 속도가 나오게 튜닝하자. 
- 방법 세가지
  - 철저한 실시간 시스템에 주로 사용되는 시간 분배
  - 성능에 꾸준한 관심 갖기 : 자주 실행되지 않는 코드에 매달리지 말자. 
  - 90% 비율의 장점만 활용한다. 잘 쪼개자. 
    - 성능 튜닝에 할애할 시간이 생긴다.
    - 정밀한 분석이 가능해진다. 
