# Ch.06 객체와 자료 구조

- 남들이 **변수에 의존하지 않게 만들고자 하는 것**이 변수를 비공개(private)로 만드는 이유이다.

## 자료 추상화
```
public interface Vehicle {
  double getFuelTankCapacityInGallons();
  double getGallonsOfGasoline();
}
```
처럼 자료를 세세하게 공개하기 보다는 아래처럼 **추상적인 개념으로 표현하는 편**이 좋다.
```
public interface Vehicle {
  double getPercentFuelRemaining();
}  
```

- 개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다.

## 자료 / 객체 비대칭

### (자료 구조를 사용하는) 절차적인 코드
- 기존 자료 구조를 변경하지 안으면서 **새 함수**를 추가하기 쉽다.
- 모든 함수를 고쳐야 하기 때문에 새로운 자료 구조를 추가하기 어렵다.
- 자료 구조는 무조건 함수 없이 **공개 변수만** 포함

### 객체 지향 코드
- 기존 함수를 변경하지 않으면서 **새 클래스**를 추가하기 쉽다.
- 모든 클래스를 고쳐야 하기 때문에 새로운 함수를 추가하기 어렵다.
- 객체는 비공개 **변수 + 공개 함수**를 포함 

> 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다! 

## 디미터 법칙
- 객체의 자료를 숨기고 함수를 공개하는 것이 좋다는 법칙의 휴리스틱
```
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```
- 위와 같은 코드를 **기차 충돌** 이라 부른다. 
  - 여러 객차가 한줄로 이어진 기차처럼 보이기 때문에
  - 조잡하게 보이기 때문에 피해야 한다.

위보다는 아래 코드가 더 낫다.

```
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```
- 두 개의 예제가 디미터 법칙을 어기는지 확인하려면 자료 구조를 먼저 파악해야 한다.
  - 객체라면 내부 구조를 숨겨야 하므로 확실히 디미터 법칙을 위반한다.
  - 자료 구조라면 당연히 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다.

단순 자료 구조에는 공개 변수만 포함해야하지만 **조회 함수와 설정 함수를 정의하라 요구**하는 프레임워크와 표준이 존재한다.

## 단순 자료 구조 + 조회함수 + 설정함수 

### 잡종 구조
- 절반은 객체, 절반은 자료 구조인 잡종 구조가 나올 수 있으나 되도록 피하는 편이 좋다.

### 구조체 감추기
- 객체에게 뭔가를 하라고 말해야지 속을 드러내라고 말하면 안 된다.
- 어떤 처리를 위해서 값이 필요한 것이라면 그런 처리를 해주는 함수를 작성하자.

### 자료 전달 객체
- 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다
- 자료 전달 객체(DTO) 라고 한다.
- DB에 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 객체로 변환하는 일련의 단계에서 가장 처음으로 사용하는 **구조체**
- 좀 더 일반적인 형태는 빈 구조 : private 변수 + 조회/설정함수
#### 활성 레코드
- DTO + 탐색함수
- 활성레코드는 자료 구조로 취급한다.

## 결론
- 객체는 동작을 공개하고 자료는 숨긴다. 자료 구조는 별다른 동작 없이 자료를 노출한다.
- SW 개발자는 편견 없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다!
