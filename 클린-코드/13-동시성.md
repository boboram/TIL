# 동시성 

> 객체는 처리의 추상화다. 스레드는 일정의 추상화다. 

- 동시성과 깔끔한 코드는 양립하기 어렵다.
- 깊숙한 곳에 문제가 있는 동시성 코드는 시스템이 부하를 받기 전까지 멀쩡하게 돌아간다. 

## 동시성이 필요한 이유는? 
- **무엇과 언제**를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다. 구조적인 관점에서 프로그램은 거대한 루프 하나가 아니라 작은 협력 프로그램 여럿으로 보인다. 
  - 서블릿 프로그램은 자신만의 세상에서 돌아간다. 
- 구조적 개선만을 위해 동시성을 선택하는 것은 아니다. 아래와 같은 경우에 성능 높이기가 가능 
  - 응답 시간, 작업 처리량 개선 
  - 한 번에 여러 사용자 처리 
  - 정보를 대량으로 분석  

### 미신과 오해 
- 동시성이 필요한 경우는 존재하지만 동시성은 어렵다. 다음은 미신과 오해다. 
  - 동시성은 **항상** 성능을 높여준다. : 아니다. **때로** 높여준다. 동시에 처리하는 **독립적인 경우가 많다면** 성능이 높아진다. 
  - 동시성을 구현해도 설계는 변하지 않는다. : **무엇과 언제**를 분리하면 시스템 구조가 크게 달라진다.
  - 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다. 
    - 컨테이너 작동 원리, 동시 수정 방법, 데드락 피하는 방법에 대해 알아야 한다. 
- 다음은 동시성에 대한 타당한 생각 
  - 동시성은 다소 부하를 유발한다. 
  - 동시성은 복잡하다.
  - 일반적으로 동시성 버그는 재현이 어렵다. : 일회성 문제로 여겨 무시하기 쉽다.
  - 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

### 난관 
- 왜 동시성을 구현하기 어려울까?
  - 두 스레드가 같은 변수를 동시에 참조하면 잘못된 결과가 나오는 경우가 발생 

### 동시성 방어 원칙 
- 아래는 동시성으로부터 시스템을 방어하는 원칙과 기술이다.
  - 단일 책임 원칙(SRP, Single Responsibility Principle) : 코드를 변경하는 이유는 단 하나
> 동시성 코드는 다른 코드와 분리하라
- 따름 정리
  - **자료 범위를 제한하라**
    - 공유 객체를 사용하는 코드 내 임계영역을 `synchronized` 키워드로 보호하라고 권장 
      - 임계영역(critical section) : 동시 사용을 막아야만 프로그램이 올바로 동작하는 보호받는 코드 영역 
      - 임계영역의 수를 줄일 것  
    - 권장 : 자료를 캡슐화하고 공유 자료를 최대한 줄여라 
  - **자료 사본을 사용하라**
    - 객체를 복사해 **읽기 전용**으로 사용한다. 
  - **스레드는 가능한 독립적으로 구현하라**
    - 다른 스레드와 자료를 공유하지 않는다. 
    - 권장 : 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라. 

## 라이브러리를 이해하라 
- 스레드 안전한 컬렉션 사용  
- 서로 무관한 작업 수행시 executor 프레임워크 사용 
- 가능한 스레드가 차단(blocking) 되지 않는 방법 사용 
- 스레드 안전하지 못한 라이브러리 존재 
- 좀 더 복잡한 동시성 설계를 위해 지원되는 클래스 
  - ReentrantLock : 한 메서드에서 잠그고 다른 메서드에서 푸는 락 
  - Semaphore : 개수가 존재하는 락 
  - CountDownLatch : 지정된 수만큼 이벤트 발생 후 대기 중인 스레드 모두 해제하는 락 
- 권장 : 언어가 제공하는 클래스를 검토하자. 

## 실행 모델을 이해하라 
- 다중 스레드 관련 몇 가지 기본 용어 
  - 한정된 자원(Bound Resource) : 크기나 숫자가 제한적, DB 연결, 읽기/쓰기 버퍼 등 
  - 상호 배제(Mutual Exclusion) : 한 번에 한 스레드만 공유 
  - 기아(Starvation) : 스레드가 굉장히 오랫동안 자원을 기다림
  - 데드락(Deadlock) : 여러 스레드가 서로가 끝나기를 기다림 
  - 라이브락(Livelock) : 락을 거는 단계에서 각 스레드가 서로를 방해
- 실행 모델 
  - **생산자-소비자** 
    - 한정된 대기열 사용
    - 올바른 대기열 사용을 위해 생산자(자원 생성하는 자)와 소비자(자원 쓰는 자)는 시그널을 보낸다.
    - 시그널을 주고 받기 때문에 잘못 구현한 경우 자원을 사용 가능하거나 자원을 생성 가능함에도 서로 기다리는 상황이 발생할 수 있음 
  -  **읽기-쓰기**
      - 기아와 처리율의 적절한 조화 필요 
      - 읽기만 계속 하면 처리율은 증가하지만 쓰기 버퍼가 계속해서 기다리기 때문에 기아상태 발생 
      - 쓰기만 계속 하면 읽을 수 없기 때문에 처리율 떨어짐 
  - **식사하는 철학자들**
    - 철학자 : 스레드, 포크 : 자원
    - 배가 고프지 않은 철학자들은 생각하며 시간 보내기
    - 배가 고프면 양손에 포크를 들고 스파게티 먹는다.
      - 양손에 포크를 안 쥐면 못 먹고 
      - 양쪽 중 한명이라도 포크를 사용하면 먹지 못함, 기다림 
    - 다 먹으면 배가 고플 때까지 다시 생각에 잠김 
    - 주의해서 설계하지 않으면 데드락, 라이브락, 처리율 저하, 효율성 저하 등 발생 

## 동기화하는 메서드 사이에 존재하는 의존성을 이해하라 
- 동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생김 
- **공유 객체 하나에는 하나의 메서드만 사용하라**
- 공유 객체 하나에 여러 메서드가 필요한 경우라면 
  - 클라이언트에서 잠금 | 서버에서 잠금 | 연결 서버 세가지 방법을 고려한다. 

## 동기화하는 부분을 작게 만들어라 
- 임계영역을 보호하기 위해서는 synchronized를 선언해야 하지만 이를 남발해서는 안된다. 
- 동기화 부분을 최대한 작게 만든다. 

## 올바른 종료 코드는 구현하기 어렵다. 
- 개발 초기부터 종료 코드를 고민하고 동작하게 구현하라. 생각보다 오래 걸리고 어려우므로 **이미 나온 알고리즘을 검토하자** 

## 스레드 코드 테스트하기 
- 동시성 코드는 올바르다고 증명해내기 현실적으로 불가능하다. 
- 충분히 테스트한다. 문제를 노출하는 테스트 케이스를 작성하고 설정과 부하를 바꿔가며 자주 돌려라. 
- 구체적인 지침 
  - 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
  - 다중 스레드를 고려하지 않은 **순차 코드부터 제대로 돌게 만들자** : 스레드를 모르는 POJO를 만든다. 스레드 외/내부 코드를 **동시에 디버깅하지 않는다**
  - 다양한 환경에 넣을 수 있는 스레드 코드를 구현하라 : 다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있는 코드를 구현하라 
  - 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라 
  - 프로세서 수보다 많은 스레드를 돌려보라 : 문제 있는 코드 발견 가능 
  - 다른 플랫폼에서 돌려보라 : 환경마다 다중 스레드 코드는 다르게 돌아간다. 모든 목표 플랫폼에서 코드를 돌려라. 
  - 코드에 보조 코드를 넣어 돌려라. **강제로 실패를 일으키게 해보라.**



> 다중 스레드는 올바로 구현하기 어렵다. 하지만 깔끔한 접근 방식을 취한다면 코드가 올바로 돌아갈 가능성이 극적으로 높아진다.
