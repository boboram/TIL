# Chap 05. 애그리게잇과 전술적 설계 

## 애그리게잇 패턴 
- 애그리게잇은 1개 이상의 엔터티로 구성되고, 그중 한 엔터티는 에그리게잇 루트라고 부른다.
- 애그리게잇은 그 구성에 값 객체를 포함할 수 있다.
  - value object : 불변의 개념적 완전성을 모델링, 고유한 식별성이 없으며 그야말로 값이다.
- 애그리게잇의 루트 엔터티는 애그리게잇 안의 다른 모든 요소를 소유하며 애그리게잇의 개념적 명칭이다.
- 일관성 있는 트랜잭션 경계를 형성
  - 트랜잭션이란 애그리게잇에 대한 변경을 독립시키고, SW가 언제나 충실히 준수해야 하는 규칙인 비즈니스 불변성을 각 비즈니스 오퍼레이션에 맞게 일관성을 보장하는 방법
  - 경계 형성 이유 : 애그리게잇이 유효한 상태인지, 아닌지를 결정하는 것은 비즈니스와 관련돼 있는 일이기 때문
  - 각 애그리게잇은 별도 분리된 트랜잭션으로 수정, 커밋된다.
  - **비즈니스 규칙은 단일 트랜잭션을 마쳤을 때, 어떤 것이 전체적으로 완전하게 그리고 일관성 있게 처리돼야 하는지를 결정하는 근거라는 것이다.**

## 애그리게잇 경험 법칙 
- 애그리게잇 경계 내에서 비즈니스 불변사항들을 보호하라.
  - 트랜잭션이 커밋될 때 비즈니스의 일관성이 지켜지는 것에 기반을 두고 애그리게잇 구성 요소를 결정해야 한다.
- 작은 애그리게잇을 설계하라.
  - 각 애그리게잇의 메모리 사용량과 트랜잭션 범위가 비교적 작아야 함을 강조
  - 연관된 각 작업이 한 명의 개발자가 관리할 수 있을만큼 작기 때문에 각 애그리게잇이 좀 더 쉬워지는 부가적인 이득을 얻을 수 있으며, 테스트 또한 보다 더 쉬워진다.
  - SRP(단일책임원칙) 준수할 것
- 오직 ID를 통해 다른 애그리게잇을 참고하라.
  - 더 적은 메모리 요구와 리파지토리로부터의 빠른 로딩을 통해 애그리게잇 설계를 작고 효율적으로 유지할 수 있게 해준다.
  - 애그리게잇을 다른 형태의 저장 매커니즘으로 쉽게 저장 가능 
- 결과적 일관성을 사용해 다른 애그리게잇을 갱신하라.

## 애그리게잇 모델링 
- 비즈니스 로직이 도메인 모델을 넘어 애플리케이션 서비스까지 새어 나가지 않도록 주의 
- 모든 애그리게잇 루트 엔터티는 전체 시스템에서 고유한 식별성을 가져야 한다.
- 애그리게잇을 찾는 데 필요한 본질적 속성이나 필드들을 찾는다.
  - 본질적 속성을 위해 getters 와 같은 간단한 행위 추가 가능
- 복잡한 행위 추가
  - 언제나 바운디드 컨텍스트가 보편언어를 따르도록 한다.
  - 생각했던 부분들을 만드는 데 급급해서는 안된다. 

## 추상화는 조심스럽게 선택 
- 높은 수준의 추상화 구현이라는 덫에 현혹X
- 팀이 정의한 도메인 전문가의 멘탈 모델에 따라 보편언어를 모델링해야 한다.
- 지금 당장 요구하는 것을 모델링하자.
 - 우선적으로 중요치 않은 문제를 해결하려다가 필요 이상으로 많은 코드가 생산된다.

## 올바른 크기의 애그리게잇 구성 
- 애그리게잇 설계의 두 번째 규칙인 **작은 애그리게잇을 설계하라**에 집중하자.
- 애그리게잇 설계의 첫 번째 규칙인 **애그리게잇 경계 내의 비즈니스 불변사항을 보호하라**로 관심을 돌리자.
- 반응에 맞춘 갱신이 일어나는 시간은 얼마나 걸릴지 도메인 전문가에 확인하자.
- 각각의 애그리게잇들이 **즉시 처리**돼야 할 경우, 동일한 애그리게잇 경계 안에 그 2개의 엔터티를 구성하는 것을 긍정적으로 검토해야 한다.
- 각각의 애그리게잇들이 **주어진 시간에 따라 각각 반응**하는 경우, 애그리게잇 설계의 네 번째 규칙인 **결과적 일관성을 사용해 다른 애그리게잇을 갱신하라**

## 테스트 
- 단위 테스트를 위해 애그리게잇을 철저하게 캡슐화되도록 설계하자.

## VELOG 링크
- https://velog.io/@bona/domain-driven-design-distilled-05
